<p>Storage data structure of all <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Relationship">Relationship</a> objects.</p><p>It is preferable to not store the RelationshipTable as part of the <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#LogicProblem">LogicProblem</a> object and simply re-generate it from the <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Clue">Clues</a> and <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Constraint">Constraint</a>, but instead be fields of the application <a class="tc-tiddlylink tc-tiddlylink-missing" href="#Puzzled">Puzzled</a> of the FXML controller, along with <strong>dirtyness</strong>. There are no advantages to adding relationships in a chronological order in the data structure, with a view to simplify undo because e.g. there is no temporal relationship between two constraints. Instead the full table can be initialized when the problem is created or loaded.</p><p>The most efficient data structure for the <strong>RelationshipTable</strong> seems to be a fixed HashMap where an <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Item">Item</a> HashSet of 2 elements is used as key (sets are not concerned about element ordering, contrary to pairs) and a <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Relationship">Relationship</a> object is used as value. A regular 2D array is very inefficient because of the triangular nature of the grid (see below). <strong><span><a class="tc-tiddlylink tc-tiddlylink-missing" href="#HashMap%3CTreeSet%3CItem%3E%2CRelationship%3E">HashMap&lt;TreeSet&lt;Item&gt;,Relationship&gt;</a></span></strong> seems to be the best data structure (the <span><a class="tc-tiddlylink tc-tiddlylink-missing" href="#TreeSet">TreeSet</a></span> class is an ordered set. Since the <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#positionGridCell">positionGridCell</a><span><a class="tc-tiddlylink tc-tiddlylink-missing" href="#(TreeSet%3CItem%3E)">(TreeSet&lt;Item&gt;)</a></span> algorithm makes computation using the lower and higher of the two item (ordered determined by the <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Category">Category</a> each item belong -&gt; hence the <span><a class="tc-tiddlylink tc-tiddlylink-missing" href="#TreeSet">TreeSet</a></span> <span><a class="tc-tiddlylink tc-tiddlylink-missing" href="#Comparator">Comparator</a></span> will use the same technique), it is best to have a two-member ordered set feeding it. It also helps for the <strong>RelationshipTable</strong> because no matter how the items are parsed from clues, they will result in the same <span><a class="tc-tiddlylink tc-tiddlylink-missing" href="#TreeSet">TreeSet</a></span> and hence the same mapped <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Relationship">Relationship</a>.</p><p>Some conversion of the relationship key to the <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#GridCell">GridCell</a> location will be needed..</p><p>When a problem is loaded, the application needs to create the entire <strong>RelationshipTable</strong>. The <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Relationship">Relationship</a> object references (pointers) are passed around when adding to the double-linked lists. The <strong>RelationshipTable</strong> needs to be able to retrieve any <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Relationship">Relationship</a> object reference by specifying the &quot;coordinates&quot; of the values it represents.
Relationships that are anchored (anywhere upstream) to a clue or a constraint are immutable and will site with a gray background. Constraints entered by the user will show their <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Relationship">Relationship</a> in red.</p><p>For a number <em>N</em> of categories of <em>n</em> items, the layout of the grid complies with the formula for triangular patterns such that:</p><table><tbody><tr class="evenRow"><th>Number of Categories N</th><th>Total grid width &amp; height<br>(N-1)n</th><th>Number of category squares<br>N(N-1)/2</th><th>Total number of relationships<br>n<sup>2</sup>N(N-1)/2</th></tr><tr class="oddRow"><td align="center">2</td><td align="center">n</td><td align="center">1</td><td align="center">n<sup>2</sup></td></tr><tr class="evenRow"><td align="center">3</td><td align="center">2n</td><td align="center">3</td><td align="center">3n<sup>2</sup></td></tr><tr class="oddRow"><td align="center">4</td><td align="center">3n</td><td align="center">6</td><td align="center">6n<sup>2</sup></td></tr><tr class="evenRow"><td align="center">5</td><td align="center">4n</td><td align="center">10</td><td align="center">10n<sup>2</sup></td></tr><tr class="oddRow"><td align="center">6</td><td align="center">5n</td><td align="center">15</td><td align="center">15n<sup>2</sup></td></tr></tbody></table>